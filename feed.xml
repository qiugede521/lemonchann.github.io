<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kekxv 个人博客</title>
  <icon>http://kekxv.github.io/icon.png</icon>
  <subtitle>kekxv</subtitle>
  <link href="http://kekxv.github.io/feed.xml" rel="self"/>
  
  <link href="http://kekxv.github.io/"/>
  <updated>2021-08-19T15:24:45.183Z</updated>
  <id>http://kekxv.github.io/</id>
  
  <author>
    <name>kekxv</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows自带的端口转发</title>
    <link href="http://kekxv.github.io/2021/08/07/Port%20forwarding%20that%20comes%20with%20Windows/"/>
    <id>http://kekxv.github.io/2021/08/07/Port%20forwarding%20that%20comes%20with%20Windows/</id>
    <published>2021-08-07T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;通过 &lt;code&gt;Windows&lt;/code&gt; 实现端口转发。本文为参考转发文章&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;Portproxy&lt;/code&gt;模式下的&lt;code&gt;Netsh&lt;/code&gt;命令即能实现&lt;code&gt;Windows&lt;/code&gt;系统中的端口转发，转发命令如下:&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;netsh interface portproxy add v4tov4 listenaddress=[localaddress] listenport=[localport] connectaddress=[destaddress]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="windows" scheme="http://kekxv.github.io/categories/windows/"/>
    
    
    <category term="notes" scheme="http://kekxv.github.io/tags/notes/"/>
    
    <category term="windows" scheme="http://kekxv.github.io/tags/windows/"/>
    
    <category term="proxy" scheme="http://kekxv.github.io/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>bazel 笔记 01</title>
    <link href="http://kekxv.github.io/2021/08/07/bazel%20notes%2001/"/>
    <id>http://kekxv.github.io/2021/08/07/bazel%20notes%2001/</id>
    <published>2021-08-07T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;Bazel - a fast, scalable, multi-language and extensible build system&lt;/p&gt;
&lt;p&gt;在使用 &lt;code&gt;bazel&lt;/code&gt; 许久之后，开始做一下记录，以记录一些奇奇怪怪的处理方式（？）。&lt;/p&gt;</summary>
    
    
    
    <category term="bazel" scheme="http://kekxv.github.io/categories/bazel/"/>
    
    
    <category term="notes" scheme="http://kekxv.github.io/tags/notes/"/>
    
    <category term="bazel" scheme="http://kekxv.github.io/tags/bazel/"/>
    
  </entry>
  
  <entry>
    <title>docker swarm替代docker-compose</title>
    <link href="http://kekxv.github.io/2021/08/07/docker%20swarm%E6%9B%BF%E4%BB%A3docker-compose/"/>
    <id>http://kekxv.github.io/2021/08/07/docker%20swarm%E6%9B%BF%E4%BB%A3docker-compose/</id>
    <published>2021-08-07T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;使用 docker-compose 管理本地容器组，是非常方便的手段，但是最近遇到一个 bug，决定使用 docker stack /swarm 替代 docker-compose 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;命令行生成二维码可以试试 &lt;code&gt;echo &amp;quot;二维码内容&amp;quot; | qrencode -o - -t UTF8&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事情是这样的，在 &lt;code&gt;docker-compose.yaml&lt;/code&gt; 内定义了 &lt;code&gt;network&lt;/code&gt;.&lt;code&gt;aliases&lt;/code&gt; 之后，在测试的时候，其他容器能够正常通过 &lt;code&gt;aliases&lt;/code&gt; 对其进行访问，但是，到了实际部署的时候，很容易失败，例如重启之后，或者某个容器意外或者手动重启之后，都有可能导致该情况，导致很湿郁闷。&lt;/p&gt;
&lt;p&gt;遂，在查找资料之后，决定替换掉 &lt;code&gt;docker-compose&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ps：&lt;code&gt;docker-compose&lt;/code&gt; 的配置 &lt;code&gt;depends_on&lt;/code&gt; 只会控制控制启动顺序，并不会等待所需容器启动成功之后再启动下一 容器&lt;br&gt;简单来说，启动容器&lt;code&gt;数据库&lt;/code&gt;之后会马上启动容器&lt;code&gt;应用&lt;/code&gt;，并不在乎&lt;code&gt;应用&lt;/code&gt;容器需要&lt;code&gt;数据库&lt;/code&gt;容器才能正常运行，此时可能会造成 &lt;code&gt;应用&lt;/code&gt; 容器无法找到数据库而意外退出。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="docker" scheme="http://kekxv.github.io/categories/docker/"/>
    
    
    <category term="linux" scheme="http://kekxv.github.io/tags/linux/"/>
    
    <category term="docker" scheme="http://kekxv.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>kProxyCpp 服务端软件</title>
    <link href="http://kekxv.github.io/2021/08/07/kProxyCpp%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BD%AF%E4%BB%B6/"/>
    <id>http://kekxv.github.io/2021/08/07/kProxyCpp%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BD%AF%E4%BB%B6/</id>
    <published>2021-08-07T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;承接自 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL2tla3h2L2tIdHRwZA==&quot;&gt;kHttpd&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt; 项目。&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;kHttpd&lt;/code&gt; 项目使用了 &lt;code&gt;libevent&lt;/code&gt; 开源库，其中某些特性导致使用上面不太方面（仅仅指的是我个人而言），所以重新开发了本项目。&lt;/p&gt;
&lt;h1 id=&quot;功能说明&quot;&gt;&lt;a href=&quot;#功能说明&quot; class=&quot;headerlink&quot; title=&quot;功能说明&quot;&gt;&lt;/a&gt;功能说明&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;http server&lt;/code&gt; 实现， &lt;code&gt;http server&lt;/code&gt; 服务端功能，使用线程池为每个连接进行处理，所以每个请求都可以阻塞（但是并不建议，除非某种特定的场景，例如进行http代理服务，必须等到对方回应，不使用 &lt;code&gt;libevent&lt;/code&gt; 其中一个原因）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;WebSocket server&lt;/code&gt; 实现，当前项目实现了&lt;code&gt;WebSocket server&lt;/code&gt;端代码，可以使用 c/c++ 愉快的开发&lt;code&gt;WebSocket&lt;/code&gt;项目，同时&lt;code&gt;WebSocket&lt;/code&gt;服务端也支持&lt;code&gt;http server&lt;/code&gt;，也就是同一个端口同时使用&lt;code&gt;WebSocket server&lt;/code&gt; 以及 &lt;code&gt;http server&lt;/code&gt;，使得更方便一些。使用&lt;code&gt;WebSocket server&lt;/code&gt;的情况下，请根据实际情况，加大线程数量以及监听数量，否则可能造成后续连接被阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;CGI&lt;/code&gt; 功能实现，目前实现 &lt;code&gt;CGI&lt;/code&gt; 调用 &lt;code&gt;php&lt;/code&gt;，可以使用&lt;code&gt;php&lt;/code&gt;作为动态脚本进行开发，不过现在还未实现 &lt;code&gt;php&lt;/code&gt;的&lt;code&gt;POST&lt;/code&gt;模式，即还未将 &lt;code&gt;php&lt;/code&gt; &lt;code&gt;body&lt;/code&gt;数据传入给&lt;code&gt;CGI&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="c/c++" scheme="http://kekxv.github.io/categories/c-c/"/>
    
    
    <category term="c/c++" scheme="http://kekxv.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>ssh 隧道端口转发</title>
    <link href="http://kekxv.github.io/2021/08/07/ssh%20%E9%9A%A7%E9%81%93%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    <id>http://kekxv.github.io/2021/08/07/ssh%20%E9%9A%A7%E9%81%93%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</id>
    <published>2021-08-07T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;在部分情况下，没有办法直接访问到目标机器，需要通过中转的方式进行访问，一般使用代理，或者VPN等组网方式，使用端口转发的方式其实也是不错的。&lt;/p&gt;
&lt;p&gt;这里简单介绍一下 &lt;code&gt;ssh&lt;/code&gt; 的代理方式.&lt;/p&gt;</summary>
    
    
    
    <category term="ssh" scheme="http://kekxv.github.io/categories/ssh/"/>
    
    
    <category term="ssh" scheme="http://kekxv.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>bazel 工具链</title>
    <link href="http://kekxv.github.io/2021/08/06/bazel%20toolchain%2001/"/>
    <id>http://kekxv.github.io/2021/08/06/bazel%20toolchain%2001/</id>
    <published>2021-08-06T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近在使用 &lt;code&gt;bazel&lt;/code&gt; ，尝试使用交叉编译，在这做个记录&lt;/p&gt;
&lt;p&gt;配置的地方有几个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;.bazelrc&lt;/code&gt; 文件配置，用于激活 &lt;code&gt;config&lt;/code&gt; 配置&lt;/li&gt;
&lt;li&gt;创建 &lt;code&gt;toolchain&lt;/code&gt; 目录，并创建&lt;code&gt;BUILD&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;创建对应的 &lt;code&gt;.bzl&lt;/code&gt; 文件&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="bazel" scheme="http://kekxv.github.io/categories/bazel/"/>
    
    
    <category term="notes" scheme="http://kekxv.github.io/tags/notes/"/>
    
    <category term="bazel" scheme="http://kekxv.github.io/tags/bazel/"/>
    
  </entry>
  
  <entry>
    <title>安卓模拟自动注入</title>
    <link href="http://kekxv.github.io/2021/08/05/Android%20simulation%20automatic%20injection/"/>
    <id>http://kekxv.github.io/2021/08/05/Android%20simulation%20automatic%20injection/</id>
    <published>2021-08-05T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.179Z</updated>
    
    
    <summary type="html">&lt;p&gt;本项目是用于模拟自动注入，通过添加注解&lt;code&gt;@Autowired&lt;/code&gt;，方便在安卓下能够更好的自动注入自动添加对象，不需要自己给每一个类进行&lt;code&gt;Instance&lt;/code&gt;维护。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://kekxv.github.io/categories/java/"/>
    
    
    <category term="android" scheme="http://kekxv.github.io/tags/android/"/>
    
    <category term="java" scheme="http://kekxv.github.io/tags/java/"/>
    
    <category term="injection" scheme="http://kekxv.github.io/tags/injection/"/>
    
  </entry>
  
  <entry>
    <title>gradle发布到github packages</title>
    <link href="http://kekxv.github.io/2021/08/03/gradle%E5%8F%91%E5%B8%83%E5%88%B0github%20packages/"/>
    <id>http://kekxv.github.io/2021/08/03/gradle%E5%8F%91%E5%B8%83%E5%88%B0github%20packages/</id>
    <published>2021-08-03T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近弄了个&lt;code&gt;Android&lt;/code&gt;的模拟自动注入的库，在给别人用的时候，需要发送 &lt;code&gt;jar&lt;/code&gt; 或者 &lt;code&gt;aar&lt;/code&gt; 给对方，这就导致我可能需要保留一份，否则每次都需要重新编译生成。为了 &lt;del&gt;偷懒&lt;/del&gt;&lt;br&gt;增加效率，在查询资料之后，将其发布到了&lt;code&gt;github packages&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;准备工作：需要&lt;code&gt;github&lt;/code&gt;账号（废话），生成&lt;code&gt;GitHub token&lt;/code&gt;需要有写权限（如果只是使用不需要，如果需要推送则需要），将账号(&lt;code&gt;GITHUB_USER&lt;/code&gt;)&lt;br&gt;和&lt;code&gt;token&lt;/code&gt;(&lt;code&gt;GITHUB_PERSONAL_ACCESS_TOKEN&lt;/code&gt;)配置到用户目录下&lt;code&gt;~/.gradle/gradle.properties&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;如果发布返回4**系列错误，原因可能是这几个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;GroupPageId&lt;/code&gt;或者&lt;code&gt;ArtificatId&lt;/code&gt;使用了大写，需要改为小写。&lt;/li&gt;
&lt;li&gt;当前&lt;code&gt;GroupPageId&lt;/code&gt;或者&lt;code&gt;ArtificatId&lt;/code&gt;已经在使用了！！！，需要修改，或者把在使用的删掉。。。。&lt;/li&gt;
&lt;li&gt;账号密码(&lt;code&gt;Token&lt;/code&gt;)错误。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="android" scheme="http://kekxv.github.io/categories/android/"/>
    
    
    <category term="android" scheme="http://kekxv.github.io/tags/android/"/>
    
    <category term="java" scheme="http://kekxv.github.io/tags/java/"/>
    
    <category term="github" scheme="http://kekxv.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV ORB 模板匹配</title>
    <link href="http://kekxv.github.io/2021/08/02/OpenCV%20ORB%20%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/"/>
    <id>http://kekxv.github.io/2021/08/02/OpenCV%20ORB%20%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D/</id>
    <published>2021-08-02T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;在某些情况下，我们需要用一个已知的物体，在一个场景内进行匹配，比如有一张身份证，然后想要在桌子上找到他的位置。比如以下两张图片：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;身份证图片：&lt;/p&gt;
&lt;img src=&quot;/images/20210807/12/201912181125218966050.jpg&quot; alt=&quot;韦小宝&quot; width=&quot;300&quot; /&gt;

&lt;p&gt;桌子图片：&lt;/p&gt;
&lt;img src=&quot;/images/20210807/12/201912181127039744167.jpg&quot; alt=&quot;韦小宝桌子&quot; width=&quot;400&quot; /&gt;

&lt;p&gt;(什么？没有桌子？哦，不要在意这些细节问题，嗯。)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果想要从其中桌子图片找到身份证图片的话，我们可以使用 OpenCV 的 ORB特征检测器（SIFT和SURF已获得专利，如果要在实际应用中使用它，则需要支付许可费，而 ORB 速度和性能也不差）。&lt;/p&gt;</summary>
    
    
    
    <category term="opencv" scheme="http://kekxv.github.io/categories/opencv/"/>
    
    
    <category term="c/c++" scheme="http://kekxv.github.io/tags/c-c/"/>
    
    <category term="opencv" scheme="http://kekxv.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>小尺寸电脑对比</title>
    <link href="http://kekxv.github.io/2021/08/01/Small%20size%20computer%20comparison/"/>
    <id>http://kekxv.github.io/2021/08/01/Small%20size%20computer%20comparison/</id>
    <published>2021-08-01T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;在需要带着笔记本出门的情况下，相对于如今动不动就 &lt;code&gt;15寸+&lt;/code&gt; 的笔记本电脑，我更喜欢携带一些小尺寸的电脑，毕竟，每天上下班背电脑是真的重。&lt;/p&gt;</summary>
    
    
    
    <category term="notes" scheme="http://kekxv.github.io/categories/notes/"/>
    
    
    <category term="notes" scheme="http://kekxv.github.io/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>reposync 同步镜像源</title>
    <link href="http://kekxv.github.io/2021/08/01/reposync%20%E5%90%8C%E6%AD%A5%E9%95%9C%E5%83%8F%E6%BA%90/"/>
    <id>http://kekxv.github.io/2021/08/01/reposync%20%E5%90%8C%E6%AD%A5%E9%95%9C%E5%83%8F%E6%BA%90/</id>
    <published>2021-08-01T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;某些情况下，我们只有内网的环境，无法很好的使用 &lt;code&gt;yum&lt;/code&gt; 镜像源，进行安装，所以我们可以选择搭建本地镜像源站来使用。&lt;/p&gt;
&lt;p&gt;本地镜像源站最简单的方式是使用安装的&lt;code&gt;光盘&lt;/code&gt;或者&lt;code&gt;ISO&lt;/code&gt;文件作为资源站点。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kekxv.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="http://kekxv.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>nmcli 简单用法</title>
    <link href="http://kekxv.github.io/2021/07/16/nmcli%20%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/"/>
    <id>http://kekxv.github.io/2021/07/16/nmcli%20%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/</id>
    <published>2021-07-16T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;在Linux系列下，我们连接WiFi的时候，可以使用nmcli作为管理工具，进行WiFi连接断开等操作，操作也相对方便。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nmcli&lt;/code&gt; 不仅仅支持操作 &lt;code&gt;Wi-Fi&lt;/code&gt;，还支持操作所有网络设备&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提示：&lt;br&gt;在&lt;code&gt;centos7&lt;/code&gt;某些情况下，以太网并没有自动连接网络，可以使用&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nmcli connection modify &amp;quot;设备名(ens33)&amp;quot; connection.autoconnect yes&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置自动管理，且开机自动连接。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kekxv.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="http://kekxv.github.io/tags/linux/"/>
    
    <category term="network" scheme="http://kekxv.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>gitea drone CI</title>
    <link href="http://kekxv.github.io/2021/07/06/gitea%20drone%20CI/"/>
    <id>http://kekxv.github.io/2021/07/06/gitea%20drone%20CI/</id>
    <published>2021-07-06T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;搭建 &lt;code&gt;gitea&lt;/code&gt; 仓库以及 &lt;code&gt;drone&lt;/code&gt; &lt;code&gt;CI&lt;/code&gt; 工具。&lt;/p&gt;
&lt;p&gt;因为在用的服务器是低性能&lt;code&gt;4G&lt;/code&gt;的服务器，勉强能跑起来&lt;code&gt;gitlab&lt;/code&gt;，再加上 &lt;code&gt;gitlab runner&lt;/code&gt; 跑的比较艰难，所以研究研究 &lt;code&gt;gitea&lt;/code&gt;与&lt;code&gt;drone&lt;/code&gt;方案；&lt;br&gt;嗯，坑还不少。&lt;/p&gt;
&lt;p&gt;按照文档以及他人的方案进行部署，发现基本上都能跑起来，但是，也只是能跑起来，如何用起来，并没有如何说明，所以在此处做一个记录。&lt;/p&gt;
&lt;h1 id=&quot;完成图&quot;&gt;&lt;a href=&quot;#完成图&quot; class=&quot;headerlink&quot; title=&quot;完成图&quot;&gt;&lt;/a&gt;完成图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/20210221/drone.png&quot; alt=&quot;drone完成图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="gitea" scheme="http://kekxv.github.io/categories/gitea/"/>
    
    
    <category term="ci" scheme="http://kekxv.github.io/tags/ci/"/>
    
    <category term="gitea" scheme="http://kekxv.github.io/tags/gitea/"/>
    
    <category term="git" scheme="http://kekxv.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>PHP 调用webservice</title>
    <link href="http://kekxv.github.io/2021/06/06/PHP%20%E8%B0%83%E7%94%A8webservice/"/>
    <id>http://kekxv.github.io/2021/06/06/PHP%20%E8%B0%83%E7%94%A8webservice/</id>
    <published>2021-06-06T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;很多时候，我们需要调用第三方的接口，例如使用 &lt;code&gt;PHP&lt;/code&gt;调用 &lt;code&gt;webservice&lt;/code&gt; 接口。&lt;/p&gt;
&lt;p&gt;关于 &lt;code&gt;webservice&lt;/code&gt; 接口，我们可以直接使用&lt;code&gt;SoapUi&lt;/code&gt;查看或者像对方索要具体地址函数以及参数。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;PHP&lt;/code&gt;里面调用的话，可以使用 &lt;code&gt;SoapClient&lt;/code&gt;，一般&lt;code&gt;PHP&lt;/code&gt;都会开启该扩展，并且相对也比较简单。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="http://kekxv.github.io/categories/PHP/"/>
    
    
    <category term="php" scheme="http://kekxv.github.io/tags/php/"/>
    
    <category term="webservice" scheme="http://kekxv.github.io/tags/webservice/"/>
    
  </entry>
  
  <entry>
    <title>安卓WebView高版本无法加载</title>
    <link href="http://kekxv.github.io/2021/05/06/Android%20WebView%20high%20version%20cannot%20be%20loaded/"/>
    <id>http://kekxv.github.io/2021/05/06/Android%20WebView%20high%20version%20cannot%20be%20loaded/</id>
    <published>2021-05-06T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.179Z</updated>
    
    
    <summary type="html">&lt;p&gt;在电脑虚拟机上测试的时候，发现本地&lt;code&gt;127.0.0.1&lt;/code&gt;无法开始加载，出现&lt;code&gt;net::ERR_CLEARTEXT_NOT_PERMITTED&lt;/code&gt;错误，这是由于&lt;code&gt;Android&lt;/code&gt;在&lt;code&gt;8&lt;/code&gt;的版本之后默认启用&lt;code&gt;https&lt;/code&gt;，由于项目中只是使用了&lt;code&gt;http&lt;/code&gt;，所以安全机制下拦截了。&lt;/p&gt;
&lt;p&gt;解决的办法：在&lt;code&gt;manifest&lt;/code&gt;中&lt;code&gt;application&lt;/code&gt;节点添加&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;android:usesCleartextTraffic=&amp;quot;true&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="android" scheme="http://kekxv.github.io/categories/android/"/>
    
    
    <category term="notes" scheme="http://kekxv.github.io/tags/notes/"/>
    
    <category term="android" scheme="http://kekxv.github.io/tags/android/"/>
    
    <category term="webview" scheme="http://kekxv.github.io/tags/webview/"/>
    
  </entry>
  
  <entry>
    <title>MFC OCX 开发一些注意事项</title>
    <link href="http://kekxv.github.io/2021/05/06/MFC%20OCX%20%E5%BC%80%E5%8F%91%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://kekxv.github.io/2021/05/06/MFC%20OCX%20%E5%BC%80%E5%8F%91%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2021-05-06T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;由于一些原因，居然开始 MFC OCX 的开发，这都是淘汰了多久的玩意了啊，心塞。&lt;/p&gt;
&lt;p&gt;MFC 如何进行 OCX 开发不在本文讨论之内，可以参考一下这些内容：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hrY3Nkbi9hcnRpY2xlL2RldGFpbHMvNTI5MDg3NDg=&quot;&gt;MFC ActiveX (ocx)控件的开发&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;， &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODIxNTM5NS9hcnRpY2xlL2RldGFpbHMvNzk3MTgzNTM=&quot;&gt;MFC .ocx控件开发&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;，&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYmFpZHUuY29tL3M/d2Q9bWZjKyVFNSVCQyU4MCVFNSU4RiU5MW9jeA==&quot;&gt;mfc 开发ocx&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="MFC" scheme="http://kekxv.github.io/categories/MFC/"/>
    
    
    <category term="MFC" scheme="http://kekxv.github.io/tags/MFC/"/>
    
    <category term="ocx" scheme="http://kekxv.github.io/tags/ocx/"/>
    
    <category term="c/c++" scheme="http://kekxv.github.io/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry Zero UPS</title>
    <link href="http://kekxv.github.io/2021/05/06/Raspberry%20Zero%20UPS/"/>
    <id>http://kekxv.github.io/2021/05/06/Raspberry%20Zero%20UPS/</id>
    <published>2021-05-06T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;有一款小巧的开发板：&lt;code&gt;Raspberry Zero&lt;/code&gt;，Broadcom BCM2835 SoC，它装有1 GHz ARM1176JZF-S单核CPU，Broadcom VideoCore IV @ 250 MHz GPU（仍支持高清）和512MB SDRAM；支持运行完整的&lt;code&gt;Linux (Arm系列)&lt;/code&gt;系统，并且带有&lt;code&gt;WiFi&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/20210807/03/202003172109357539136.jpg&quot; alt=&quot;树莓派zero&quot; title=&quot;树莓派zero&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然，这只是本文的主角之一，另一个主角是对应的UPS(算是吧)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/20210807/03/202003172113385662548.png&quot; alt=&quot;树莓派 UPS&quot; title=&quot;树莓派 UPS&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="raspi" scheme="http://kekxv.github.io/categories/raspi/"/>
    
    
    <category term="notes" scheme="http://kekxv.github.io/tags/notes/"/>
    
    <category term="raspi" scheme="http://kekxv.github.io/tags/raspi/"/>
    
  </entry>
  
  <entry>
    <title>Java 注意事项</title>
    <link href="http://kekxv.github.io/2021/04/06/Java%20considerations/"/>
    <id>http://kekxv.github.io/2021/04/06/Java%20considerations/</id>
    <published>2021-04-06T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;由于一些原因，步入了 &lt;code&gt;Java&lt;/code&gt; 开发的大坑。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://kekxv.github.io/categories/java/"/>
    
    
    <category term="notes" scheme="http://kekxv.github.io/tags/notes/"/>
    
    <category term="java" scheme="http://kekxv.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>树莓派 OLED 屏幕</title>
    <link href="http://kekxv.github.io/2021/04/06/%E6%A0%91%E8%8E%93%E6%B4%BE%20OLED%20%E5%B1%8F%E5%B9%95/"/>
    <id>http://kekxv.github.io/2021/04/06/%E6%A0%91%E8%8E%93%E6%B4%BE%20OLED%20%E5%B1%8F%E5%B9%95/</id>
    <published>2021-04-06T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近在研究 &lt;code&gt;IIC&lt;/code&gt;(&lt;code&gt;I2C&lt;/code&gt;)通讯，所以采购了一款支持 &lt;code&gt;IIC&lt;/code&gt; 的&lt;code&gt;OLED&lt;/code&gt;屏幕，并将其在&lt;code&gt;树莓派&lt;/code&gt;上驱动起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/20210807/03/202003311249533709127.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="raspi" scheme="http://kekxv.github.io/categories/raspi/"/>
    
    
    <category term="c/c++" scheme="http://kekxv.github.io/tags/c-c/"/>
    
    <category term="raspi" scheme="http://kekxv.github.io/tags/raspi/"/>
    
    <category term="spi" scheme="http://kekxv.github.io/tags/spi/"/>
    
    <category term="iic" scheme="http://kekxv.github.io/tags/iic/"/>
    
  </entry>
  
  <entry>
    <title>java PipedInputStream 管道吐槽</title>
    <link href="http://kekxv.github.io/2021/03/07/java%20PipedInputStream%20Pipeline/"/>
    <id>http://kekxv.github.io/2021/03/07/java%20PipedInputStream%20Pipeline/</id>
    <published>2021-03-07T10:23:48.000Z</published>
    <updated>2021-08-19T15:24:45.183Z</updated>
    
    
    <summary type="html">&lt;p&gt;最近业务上需要使用到管道，做数据缓存和通讯，使用了&lt;code&gt;PipedInputStream&lt;/code&gt;、&lt;code&gt;PipedOutputStream&lt;/code&gt;。记录一下一个隐藏的坑！&lt;/p&gt;
&lt;p&gt;在项目初期，所有调用均为正常，数据也能正常写入读取管道，遂提交代码，并且交由他人使用。&lt;/p&gt;
&lt;p&gt;然，增加功能以及业务调用之后，无法读取到数据？？？？并且在进行&lt;strong&gt;管道写&lt;/strong&gt;的时候报错&lt;code&gt;Java io ioexception read end dead&lt;/code&gt;？？？？？？？？？？&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://kekxv.github.io/categories/java/"/>
    
    
    <category term="notes" scheme="http://kekxv.github.io/tags/notes/"/>
    
    <category term="linux" scheme="http://kekxv.github.io/tags/linux/"/>
    
    <category term="java" scheme="http://kekxv.github.io/tags/java/"/>
    
  </entry>
  
</feed>
